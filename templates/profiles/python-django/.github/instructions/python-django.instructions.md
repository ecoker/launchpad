---
name: Python + Django
description: Batteries-included Python web — admin, ORM, auth, content management
applyTo: "**/*.py"
---

# Python + Django

Django is Python's Rails. Batteries-included, convention-driven, and
incredibly productive. The admin interface alone is worth it for many
applications.

## Scaffold

```sh
django-admin startproject {{name}}
cd {{name}}
python manage.py startapp core
```

Use Django's CLI and management commands. Never hand-write migration files.

### Key management commands

```sh
# Create a new app
python manage.py startapp orders

# Generate migrations from model changes
python manage.py makemigrations

# Apply migrations
python manage.py migrate

# Create superuser for admin
python manage.py createsuperuser
```

## Project structure

```
{{name}}/
  settings.py            # Project settings
  urls.py                # Root URL configuration
  wsgi.py / asgi.py      # Server entry points
orders/
  models.py              # Domain models
  views.py               # Views (thin — delegate to models/services)
  urls.py                # App-level URL patterns
  admin.py               # Admin configuration
  forms.py               # Django forms
  serializers.py         # DRF serializers (if API)
  services.py            # Complex business logic
  tests.py               # App tests
  migrations/            # Auto-generated — never hand-edit
templates/
  base.html              # Base template
  orders/
    list.html
    detail.html
static/
  css/
  js/
```

## Django conventions

### Models

- **Models are the heart of the app.** Define your domain in models. Django's
  ORM is excellent — use it.
- **Use `Meta` for ordering, constraints, indexes.**
- **Custom managers for query logic.**
- **Migrations are sacred.** Generated by `makemigrations`, never hand-edited.

```python
# orders/models.py
from django.db import models
from django.utils import timezone


class OrderQuerySet(models.QuerySet):
    def active(self):
        return self.filter(status__in=['pending', 'confirmed'])

    def for_customer(self, customer_id):
        return self.filter(customer_id=customer_id)


class Order(models.Model):
    class Status(models.TextChoices):
        PENDING = 'pending', 'Pending'
        CONFIRMED = 'confirmed', 'Confirmed'
        SHIPPED = 'shipped', 'Shipped'
        CANCELLED = 'cancelled', 'Cancelled'

    customer = models.ForeignKey('auth.User', on_delete=models.CASCADE, related_name='orders')
    status = models.CharField(max_length=20, choices=Status, default=Status.PENDING)
    total = models.DecimalField(max_digits=10, decimal_places=2)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    objects = OrderQuerySet.as_manager()

    class Meta:
        ordering = ['-created_at']
        indexes = [models.Index(fields=['customer', 'status'])]

    def confirm(self):
        self.status = self.Status.CONFIRMED
        self.save(update_fields=['status', 'updated_at'])
```

### Views

- **Class-based views for CRUD.** Django's generic CBVs handle the common
  patterns. Use them.
- **Function-based views for custom logic.** When CBVs add more complexity
  than they save, use functions.
- **Keep views thin.** Delegate complex logic to model methods or services.

```python
# orders/views.py
from django.views.generic import ListView, DetailView, CreateView
from django.contrib.auth.mixins import LoginRequiredMixin
from .models import Order
from .forms import CreateOrderForm


class OrderListView(LoginRequiredMixin, ListView):
    model = Order
    template_name = 'orders/list.html'
    paginate_by = 20

    def get_queryset(self):
        return Order.objects.for_customer(self.request.user.id).active()


class OrderCreateView(LoginRequiredMixin, CreateView):
    model = Order
    form_class = CreateOrderForm
    template_name = 'orders/create.html'
    success_url = '/orders/'

    def form_valid(self, form):
        form.instance.customer = self.request.user
        return super().form_valid(form)
```

### Admin

Django admin is a superpower. Configure it for every model:

```python
# orders/admin.py
from django.contrib import admin
from .models import Order


@admin.register(Order)
class OrderAdmin(admin.ModelAdmin):
    list_display = ['id', 'customer', 'status', 'total', 'created_at']
    list_filter = ['status', 'created_at']
    search_fields = ['customer__username', 'customer__email']
    readonly_fields = ['created_at', 'updated_at']
```

## Testing

- **pytest-django** for clean test setup.
- **Model tests for business logic.**
- **View tests with Django's test client.**
- **Use `baker` or `factory_boy`** for test data.

## What to avoid

- Hand-writing migrations.
- Business logic in views — delegate to models or services.
- Raw SQL when the ORM can handle it.
- Skipping the admin — it's free and powerful.
- Global imports in models (`from . import *`).
- N+1 queries — use `select_related` and `prefetch_related`.
